{"version":3,"file":"models/index.umd.min.js","mappings":"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","sources":["webpack://git/webpack/universalModuleDefinition","webpack://git/./node_modules/pify/index.js","webpack://git/webpack/bootstrap","webpack://git/webpack/runtime/define property getters","webpack://git/webpack/runtime/hasOwnProperty shorthand","webpack://git/webpack/runtime/make namespace object","webpack://git/./src/utils/compareStrings.js","webpack://git/./src/utils/dirname.js","webpack://git/./src/utils/rmRecursive.js","webpack://git/./src/utils/join.js","webpack://git/./src/utils/types.js","webpack://git/./src/models/FileSystem.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"git\"] = factory();\n\telse\n\t\troot[\"git\"] = factory();\n})(self, () => {\nreturn ","'use strict';\n\nconst processFn = (fn, options) => function (...args) {\n\tconst P = options.promiseModule;\n\n\treturn new P((resolve, reject) => {\n\t\tif (options.multiArgs) {\n\t\t\targs.push((...result) => {\n\t\t\t\tif (options.errorFirst) {\n\t\t\t\t\tif (result[0]) {\n\t\t\t\t\t\treject(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.shift();\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (options.errorFirst) {\n\t\t\targs.push((error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\targs.push(resolve);\n\t\t}\n\n\t\tfn.apply(this, args);\n\t});\n};\n\nmodule.exports = (input, options) => {\n\toptions = Object.assign({\n\t\texclude: [/.+(Sync|Stream)$/],\n\t\terrorFirst: true,\n\t\tpromiseModule: Promise\n\t}, options);\n\n\tconst objType = typeof input;\n\tif (!(input !== null && (objType === 'object' || objType === 'function'))) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be a \\`Function\\` or \\`Object\\`, got \\`${input === null ? 'null' : objType}\\``);\n\t}\n\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\treturn options.include ? options.include.some(match) : !options.exclude.some(match);\n\t};\n\n\tlet ret;\n\tif (objType === 'function') {\n\t\tret = function (...args) {\n\t\t\treturn options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);\n\t\t};\n\t} else {\n\t\tret = Object.create(Object.getPrototypeOf(input));\n\t}\n\n\tfor (const key in input) { // eslint-disable-line guard-for-in\n\t\tconst property = input[key];\n\t\tret[key] = typeof property === 'function' && filter(key) ? processFn(property, options) : property;\n\t}\n\n\treturn ret;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export function compareStrings(a, b) {\n  // https://stackoverflow.com/a/40355107/2168416\n  return -(a < b) || +(a > b)\n}\n","export function dirname(path) {\n  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'))\n  if (last === -1) return '.'\n  if (last === 0) return '/'\n  return path.slice(0, last)\n}\n","import { join } from './join.js'\n\n/**\n * Removes the directory at the specified filepath recursively. Used internally to replicate the behavior of\n * fs.promises.rm({ recursive: true, force: true }) from Node.js 14 and above when not available. If the provided\n * filepath resolves to a file, it will be removed.\n *\n * @param {import('../models/FileSystem.js').FileSystem} fs\n * @param {string} filepath - The file or directory to remove.\n */\nexport async function rmRecursive(fs, filepath) {\n  const entries = await fs.readdir(filepath)\n  if (entries == null) {\n    await fs.rm(filepath)\n  } else if (entries.length) {\n    await Promise.all(\n      entries.map(entry => {\n        const subpath = join(filepath, entry)\n        return fs.lstat(subpath).then(stat => {\n          if (!stat) return\n          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath)\n        })\n      })\n    ).then(() => fs.rmdir(filepath))\n  } else {\n    await fs.rmdir(filepath)\n  }\n}\n","/*!\n * This code for `path.join` is directly copied from @zenfs/core/path for bundle size improvements.\n * SPDX-License-Identifier: LGPL-3.0-or-later\n * Copyright (c) James Prevett and other ZenFS contributors.\n */\n\nfunction normalizeString(path, aar) {\n  let res = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let char = '\\x00'\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) char = path[i]\n    else if (char === '/') break\n    else char = '/'\n\n    if (char === '/') {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (\n          res.length < 2 ||\n          lastSegmentLength !== 2 ||\n          res.at(-1) !== '.' ||\n          res.at(-2) !== '.'\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf('/')\n            if (lastSlashIndex === -1) {\n              res = ''\n              lastSegmentLength = 0\n            } else {\n              res = res.slice(0, lastSlashIndex)\n              lastSegmentLength = res.length - 1 - res.lastIndexOf('/')\n            }\n            lastSlash = i\n            dots = 0\n            continue\n          } else if (res.length !== 0) {\n            res = ''\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (aar) {\n          res += res.length > 0 ? '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i)\n        else res = path.slice(lastSlash + 1, i)\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (char === '.' && dots !== -1) {\n      ++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\n\nfunction normalize(path) {\n  if (!path.length) return '.'\n\n  const isAbsolute = path[0] === '/'\n  const trailingSeparator = path.at(-1) === '/'\n\n  path = normalizeString(path, !isAbsolute)\n\n  if (!path.length) {\n    if (isAbsolute) return '/'\n    return trailingSeparator ? './' : '.'\n  }\n  if (trailingSeparator) path += '/'\n\n  return isAbsolute ? `/${path}` : path\n}\n\nexport function join(...args) {\n  if (args.length === 0) return '.'\n  let joined\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i]\n    if (arg.length > 0) {\n      if (joined === undefined) joined = arg\n      else joined += '/' + arg\n    }\n  }\n  if (joined === undefined) return '.'\n  return normalize(joined)\n}\n","export function isPromiseLike(obj) {\n  return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch)\n}\n\nexport function isObject(obj) {\n  return obj && typeof obj === 'object'\n}\n\nexport function isFunction(obj) {\n  return typeof obj === 'function'\n}\n","import pify from 'pify'\n\nimport { compareStrings } from '../utils/compareStrings.js'\nimport { dirname } from '../utils/dirname.js'\nimport { rmRecursive } from '../utils/rmRecursive.js'\nimport { isPromiseLike } from '../utils/types.js'\n\nfunction isPromiseFs(fs) {\n  const test = targetFs => {\n    try {\n      // If readFile returns a promise then we can probably assume the other\n      // commands do as well\n      return targetFs.readFile().catch(e => e)\n    } catch (e) {\n      return e\n    }\n  }\n  return isPromiseLike(test(fs))\n}\n\n// List of commands all filesystems are expected to provide. `rm` is not\n// included since it may not exist and must be handled as a special case\n// Likewise with `cp`.\nconst commands = [\n  'readFile',\n  'writeFile',\n  'mkdir',\n  'rmdir',\n  'unlink',\n  'stat',\n  'lstat',\n  'readdir',\n  'readlink',\n  'symlink',\n]\n\nfunction bindFs(target, fs) {\n  if (isPromiseFs(fs)) {\n    for (const command of commands) {\n      target[`_${command}`] = fs[command].bind(fs)\n    }\n  } else {\n    for (const command of commands) {\n      target[`_${command}`] = pify(fs[command].bind(fs))\n    }\n  }\n\n  // Handle the special cases of `rm` and `cp`\n  if (isPromiseFs(fs)) {\n    if (fs.cp) target._cp = fs.cp.bind(fs)\n    if (fs.rm) target._rm = fs.rm.bind(fs)\n    else if (fs.rmdir.length > 1) target._rm = fs.rmdir.bind(fs)\n    else target._rm = rmRecursive.bind(null, target)\n  } else {\n    if (fs.cp) target._cp = pify(fs.cp.bind(fs))\n    if (fs.rm) target._rm = pify(fs.rm.bind(fs))\n    else if (fs.rmdir.length > 2) target._rm = pify(fs.rmdir.bind(fs))\n    else target._rm = rmRecursive.bind(null, target)\n  }\n}\n\n/**\n * A wrapper class for file system operations, providing a consistent API for both promise-based\n * and callback-based file systems. It includes utility methods for common file system tasks.\n */\nexport class FileSystem {\n  /**\n   * Creates an instance of FileSystem.\n   *\n   * @param {Object} fs - A file system implementation to wrap.\n   */\n  constructor(fs) {\n    if (typeof fs._original_unwrapped_fs !== 'undefined') return fs\n\n    const promises = Object.getOwnPropertyDescriptor(fs, 'promises')\n    if (promises && promises.enumerable) {\n      bindFs(this, fs.promises)\n    } else {\n      bindFs(this, fs)\n    }\n    this._original_unwrapped_fs = fs\n  }\n\n  /**\n   * Return true if a file exists, false if it doesn't exist.\n   * Rethrows errors that aren't related to file existence.\n   *\n   * @param {string} filepath - The path to the file.\n   * @param {Object} [options] - Additional options.\n   * @returns {Promise<boolean>} - `true` if the file exists, `false` otherwise.\n   */\n  async exists(filepath, options = {}) {\n    try {\n      await this._stat(filepath)\n      return true\n    } catch (err) {\n      if (\n        err.code === 'ENOENT' ||\n        err.code === 'ENOTDIR' ||\n        (err.code || '').includes('ENS')\n      ) {\n        return false\n      } else {\n        console.log('Unhandled error in \"FileSystem.exists()\" function', err)\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Return the contents of a file if it exists, otherwise returns null.\n   *\n   * @param {string} filepath - The path to the file.\n   * @param {Object} [options] - Options for reading the file.\n   * @returns {Promise<Buffer|string|null>} - The file contents, or `null` if the file doesn't exist.\n   */\n  async read(filepath, options = {}) {\n    try {\n      let buffer = await this._readFile(filepath, options)\n      if (options.autocrlf === 'true') {\n        try {\n          buffer = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n          buffer = buffer.replace(/\\r\\n/g, '\\n')\n          buffer = new TextEncoder().encode(buffer)\n        } catch (error) {\n          // non utf8 file\n        }\n      }\n      // Convert plain ArrayBuffers to Buffers\n      if (typeof buffer !== 'string') {\n        buffer = Buffer.from(buffer)\n      }\n      return buffer\n    } catch (err) {\n      return null\n    }\n  }\n\n  /**\n   * Write a file (creating missing directories if need be) without throwing errors.\n   *\n   * @param {string} filepath - The path to the file.\n   * @param {Buffer|Uint8Array|string} contents - The data to write.\n   * @param {Object|string} [options] - Options for writing the file.\n   * @returns {Promise<void>}\n   */\n  async write(filepath, contents, options = {}) {\n    try {\n      await this._writeFile(filepath, contents, options)\n    } catch (err) {\n      // Hmm. Let's try mkdirp and try again.\n      await this.mkdir(dirname(filepath))\n      await this._writeFile(filepath, contents, options)\n    }\n  }\n\n  /**\n   * Make a directory (or series of nested directories) without throwing an error if it already exists.\n   *\n   * @param {string} filepath - The path to the directory.\n   * @param {boolean} [_selfCall=false] - Internal flag to prevent infinite recursion.\n   * @returns {Promise<void>}\n   */\n  async mkdir(filepath, _selfCall = false) {\n    try {\n      await this._mkdir(filepath)\n    } catch (err) {\n      // If err is null then operation succeeded!\n      if (err === null) return\n      // If the directory already exists, that's OK!\n      if (err.code === 'EEXIST') return\n      // Avoid infinite loops of failure\n      if (_selfCall) throw err\n      // If we got a \"no such file or directory error\" backup and try again.\n      if (err.code === 'ENOENT') {\n        const parent = dirname(filepath)\n        // Check to see if we've gone too far\n        if (parent === '.' || parent === '/' || parent === filepath) throw err\n        // Infinite recursion, what could go wrong?\n        await this.mkdir(parent)\n        await this.mkdir(filepath, true)\n      }\n    }\n  }\n\n  /**\n   * Delete a file without throwing an error if it is already deleted.\n   *\n   * @param {string} filepath - The path to the file.\n   * @returns {Promise<void>}\n   */\n  async rm(filepath) {\n    try {\n      await this._unlink(filepath)\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err\n    }\n  }\n\n  /**\n   * Delete a directory without throwing an error if it is already deleted.\n   *\n   * @param {string} filepath - The path to the directory.\n   * @param {Object} [opts] - Options for deleting the directory.\n   * @returns {Promise<void>}\n   */\n  async rmdir(filepath, opts) {\n    try {\n      if (opts && opts.recursive) {\n        await this._rm(filepath, opts)\n      } else {\n        await this._rmdir(filepath)\n      }\n    } catch (err) {\n      if (err.code !== 'ENOENT') throw err\n    }\n  }\n\n  /**\n   * Read a directory without throwing an error is the directory doesn't exist\n   *\n   * @param {string} filepath - The path to the directory.\n   * @returns {Promise<string[]|null>} - An array of file names, or `null` if the path is not a directory.\n   */\n  async readdir(filepath) {\n    try {\n      const names = await this._readdir(filepath)\n      // Ordering is not guaranteed, and system specific (Windows vs Unix)\n      // so we must sort them ourselves.\n      names.sort(compareStrings)\n      return names\n    } catch (err) {\n      if (err.code === 'ENOTDIR') return null\n      return []\n    }\n  }\n\n  /**\n   * Return a flat list of all the files nested inside a directory\n   *\n   * Based on an elegant concurrent recursive solution from SO\n   * https://stackoverflow.com/a/45130990/2168416\n   *\n   * @param {string} dir - The directory to read.\n   * @returns {Promise<string[]>} - A flat list of all files in the directory.\n   */\n  async readdirDeep(dir) {\n    const subdirs = await this._readdir(dir)\n    const files = await Promise.all(\n      subdirs.map(async subdir => {\n        const res = dir + '/' + subdir\n        return (await this._stat(res)).isDirectory()\n          ? this.readdirDeep(res)\n          : res\n      })\n    )\n    return files.reduce((a, f) => a.concat(f), [])\n  }\n\n  /**\n   * Return the Stats of a file/symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existence.\n   *\n   * @param {string} filename - The path to the file or symlink.\n   * @returns {Promise<Object|null>} - The stats object, or `null` if the file doesn't exist.\n   */\n  async lstat(filename) {\n    try {\n      const stats = await this._lstat(filename)\n      return stats\n    } catch (err) {\n      if (err.code === 'ENOENT' || (err.code || '').includes('ENS')) {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Reads the contents of a symlink if it exists, otherwise returns null.\n   * Rethrows errors that aren't related to file existence.\n   *\n   * @param {string} filename - The path to the symlink.\n   * @param {Object} [opts={ encoding: 'buffer' }] - Options for reading the symlink.\n   * @returns {Promise<Buffer|null>} - The symlink target, or `null` if it doesn't exist.\n   */\n  async readlink(filename, opts = { encoding: 'buffer' }) {\n    // Note: FileSystem.readlink returns a buffer by default\n    // so we can dump it into GitObject.write just like any other file.\n    try {\n      const link = await this._readlink(filename, opts)\n      return Buffer.isBuffer(link) ? link : Buffer.from(link)\n    } catch (err) {\n      if (err.code === 'ENOENT' || (err.code || '').includes('ENS')) {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Write the contents of buffer to a symlink.\n   *\n   * @param {string} filename - The path to the symlink.\n   * @param {Buffer} buffer - The symlink target.\n   * @returns {Promise<void>}\n   */\n  async writelink(filename, buffer) {\n    return this._symlink(buffer.toString('utf8'), filename)\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","processFn","fn","options","args","P","promiseModule","resolve","reject","multiArgs","push","result","errorFirst","shift","error","apply","this","input","Object","assign","exclude","Promise","objType","TypeError","filter","key","match","pattern","test","include","some","ret","excludeMain","create","getPrototypeOf","property","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","compareStrings","a","b","dirname","path","last","Math","max","lastIndexOf","slice","async","rmRecursive","fs","filepath","entries","readdir","rm","length","all","map","entry","subpath","joined","i","arg","isAbsolute","trailingSeparator","at","aar","res","lastSegmentLength","lastSlash","dots","char","lastSlashIndex","normalizeString","normalize","join","lstat","then","stat","isDirectory","rmdir","isFunction","isPromiseFs","isObject","targetFs","readFile","catch","e","commands","bindFs","target","command","bind","pify","cp","_cp","_rm","FileSystem","constructor","_original_unwrapped_fs","promises","getOwnPropertyDescriptor","exists","_stat","err","code","includes","console","log","read","buffer","_readFile","autocrlf","TextDecoder","fatal","decode","replace","TextEncoder","encode","Buffer","from","write","contents","_writeFile","mkdir","_selfCall","_mkdir","parent","_unlink","opts","recursive","_rmdir","names","_readdir","sort","readdirDeep","dir","subdirs","subdir","reduce","f","concat","filename","_lstat","readlink","encoding","link","_readlink","isBuffer","writelink","_symlink","toString"],"sourceRoot":""}